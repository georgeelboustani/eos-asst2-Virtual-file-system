ASST2 Design Document: System Calls At the core of this assignment our job
is to bridge the gap between kernel space and userland by implementing the
required system calls: write, read, open, close, lseek and dup2. In order
to successfully design a working solution to the problem, an understanding
of the available tools found mainly in the vfs layer was required.

In order to form the bridge between userland and kernel space, the
system calls from the user must be captured by trapframes and delegated
to the appropriate functions within the kernel. Within the kernel space,
the interaction between the user input and the virtual file system must
be carefully managed. The first is retrieving the parameters passed
in from the user. An important note here is that some parameters are
32bit and others 64bit, requiring us to carefully access each. There
are also buffer references passed in, whose locations are actually in
userspace. This too require care when dealing with them, requiring
copyin/copyout calls to move data between the kernel and userland,
as well as careful configuration of the vfs layer operations. To
successfully manage the file system calls, a file descriptor table is
maintained for each thread. This is opposed to being a global array,
allowing us to keep track of which files are opened in each process.

The file descriptor tables contain file descriptors. These represent the
files, storing important information such as the respective modes under
which the files were opened - read only, write only or read write. These
are also used to keep track of how many references there are to an
open file descriptor. This is used to to know when it is safe to close
a file, especially after a dup2 operation is performed. A reference
count is also useful when a process is forked. The file descriptor is
also responsible for tracking where in the file to write to or read
from next. It facilitates jumping from one part of the file to the
other, specifically when the lseek operation is performed. It does
this by keeping track of the current offset from the beginning of the
file each file descriptor is at. The file descriptors also store the
vnode, representing the file in the file system, and a lock used for
synchronisation of operation that might otherwise lead to conflicts.

With the file descriptor table doing all the bookkeeping for us, the next
step is to delegate to the appropriate virtual file system calls to read
from, write to and maintain access counts to each file represented by a
vnode. Essentially each function has a corresponding call, open requires
a call to vfs_open, close calls vfs_close, lseek checks with VOP_TRYSEEK
to check if the new seek position is valid for the particular node and
performs the seek, read calls VOP_READ to extract information when given
the location to read from and how much to read. Lastly, write calls
VOP_WRITE to save data from a certain location with a given length. In
order to make use of VOP_READ and VOP_WRITE, we make use of the uio
abstraction of memory blocks to physically write and read to the files.

Given that multiple processes are allowed to run simultaneously on the
same vnodes, each file descriptor has an internal lock that ensures all
data write and read operations are completely atomic such that no two
calls will overwrite the other. Additionally any duplications, opening and
closing of files cannot interrupt one another as a lock must be acquired
in order to proceed. If any errors are encountered, be it an internal
error passed up from the virtual file system, or an error raised by the
input checking performed in our file system operations, the locks are
immediately released and the error is returned. These locks ensure the
internal state of the file descriptor is consistent. This includes the
value of the offset, and the access to the vnode and its fs operations.

All system call functions have extensive input checking, notably
all functions throwing an EBADF (bad file number) if an invalid file
descriptor number is ever passed in. Each system call also immediately
returns an error should any delegated calls fail on return, such as any
vfs or VOP calls. For reading, the flags are checked to ensure the file
descriptor has been opened for read only or read and write and likewise
writing checks that the file is opened for write only and read and write,
throwing an EINVAL if the desired condition is not satisfied. Any kind
of memory allocation performed in the kernel (kmalloc) is immediately
checked for NULL and throws an ENOMEM should no memory be granted to
the required item. Open performs additional checks for flags such that
no invalid state can be achieved such as a read only and a write only
flag being set for the same file descriptor. Essentially open checks
that only one of the following three flags are set, read only, write
only or read write, rejecting any other case.

The file descriptor table is included in the thread struct, and is
intialised on thread startup in runprogram. Here we ensure the STDOUT
and STDERR are open by default, with fd’s 1 and 2, as this is what user
level applications expect. File descriptor id’s are allocated in such a
way to ensure uniqueness. An id cannot be allocated if it is already in
used by an open file in the specific process file descriptor table. The
allocation of id’s is handled through the use of a previous_fd variable
in each thread, which tracks the previously allocated descriptor. If
a file descriptor is freed, and it is lower than the previoud_fd,
then the previous_fd is updated to that fd_id. This allows us to always
allocate the smallest available id. In order to find the next available,
we search the file descriptor table from left to right, starting from
the previous_id index, until we find an index which is NULL. This index
represents the smallest next free file descriptor id. This method of id
allocation and search is more efficient than simply searching the whole
file descriptor table each time. The file descriptor table is full,
i.e. has OPEN_MAX file descriptors in it, when we cannot find a NULL
index when we search from previous_fd onwards.

Advanced Part Having implemented the file system calls with thread
safety in mind, the next step was to implement fork. The idea with
fork is that the new thread had to receive most of the old thread’s
state. For example, the new threads file descriptor table had to be the
same as the old ones. And more, the file descriptors needed to be the
same references. This made a fork act like a dup2 on these descriptors,
that way both threads shared the offset pointers in files, incremented
the refcounts and had the same reference to the vnode.

The next thing we looked at was the actual forking. So in our
implementation of fork we allocated a new trapframe to which we copied
the old threads trapframe to. This was done here to avoid the old thread
changing the trapframe when it continued execution. We created a new proc
struct using proc_create_runprogram, and we also made a copy of the old
threads address space using as_copy. It was apparent that thread_fork
contained much of the initialisation logic required for forking, so we
used it to do the work for us. We modified thread_fork to copy the old
threads file descriptor table as discussed above. We also passed the new
process struct, copy of the address space and the copy of the trapframe
as the parameters to thread_fork. We then proceeded onto the tricky part,
the entrypoint. We used the enter_forked_process stub in syscall.c as our
entry point function, and passed in the copies of the address space and
trapframe. It was important that the trapframe was on the stack of the new
thread, so we defined a static struct trapframe and copied the trapframe
passed in to this and freed the old one. We then set the address space
and activated it as required, and set the appropriate return values and
program counter variables in the trapframe. We then called mips_usermode
to handle taking the thread back to userland to continue.

Next step was to implement all PID related functions, getpid(), waitpid()
and exit(). In order to tackle these problems the very first task is
to create some data structure which will be able to delegate and take
back PIDs as required. A simple global array of processes performed
this task sufficiently. We wrapped up the given struct proc in our own
struct process for bookkeeping like storing the exitcode, exit status
and holding on to the condition variable used to synchronise between the
parent and the child during exit. Two fields were added to struct proc,
pid and parent_pid to make it easy to obtain a reference to the process
from our array, and to check if we have a parent respectively.

For getpid() to be the trivial implementation it is, the next free PID is
assigned to the proc during proc_create and if there is no more available
processes we simply free all allocated information and return with an
error. On exit or fatal we free up the process from the relevant slot
after the proc and thread are both in a destroyed or zombie state. Getpid
can now simply call curthread->t_proc->pid to retrieve the appropriate
value.

Waitpid and exit were far more trickier. In order for these two functions
to interact with one another, from parent to child, we needed some way
for them to synchronise in a concurrent environment. The core of both
functions were not too complex. Waitpid checked if the appropriate PID
and options were passed in. Since our implementation did not handle any
of the option flags we simply checked if none of the flags were passed
in. For PID, it had to be between 0 and PROC_MAX. The status was also
checked for validity by attempting to copyout to it, if it failed then
we return with the exit code provided. On a valid pass, if the child had
already exited, waitpid would have the parent collect the exit code of
the child, remove the child from the process table and free the proc and
process structs then return with the pid of the child after populating the
status pointer. If the child has not already exited, then the parent who
called waitpid will hang indefinitely using a condition variable until
the child calls exit and signals to the parent that it can collect all
the necessary information, clean up and return.

By that logic exit is much simpler than waitpid, its job is set its exit
code with _MKWAIT_EXIT, indicate that it has exited, use the condition
variable to signal the parent that it has exited, regardless of whether
or not the parent is waiting for the child, destroy the process and
thread_exit.

Kill_curthread is trivial, it is by nature quite similar to what has to
be done when an exit call is made, except we do not care about notifying
our parent or anything since it can no longer be trusted. After the
error codes are interpreted, kill_curthread simply destroys the proc,
removes the process from our global pid array and exits the thread,
effectively leaving it in a zombie state for later clean up.
